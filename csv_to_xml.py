import csv
from datetime import datetime
import xml.etree.ElementTree as ET

CSV_FILE = "tal_episodes.csv"
XML_FILE = "feed.xml"

def parse_date(date_str):
    """Parse RFC2822 or ISO8601 date to datetime"""
    if not date_str:
        return None
    for fmt in ("%a, %d %b %Y %H:%M:%S %z", "%Y-%m-%dT%H:%M:%S%z", "%Y-%m-%d"):
        try:
            return datetime.strptime(date_str, fmt)
        except ValueError:
            continue
    return None

def is_repeat(pub_date_str, release_date_str):
    pub_date = parse_date(pub_date_str)
    release_date = parse_date(release_date_str)
    if not pub_date or not release_date:
        return False
    return pub_date.isocalendar()[1] != release_date.isocalendar()[1]

# Read CSV
with open(CSV_FILE, newline="", encoding="utf-8") as f:
    reader = list(csv.DictReader(f))
    
# Sort descending by pubDate, fallback to releaseDate
def sort_key(row):
    date_str = row['pubDate'].strip() or row['releaseDate'].strip()
    dt = parse_date(date_str)
    return dt or datetime.min

rows = sorted(reader, key=sort_key, reverse=True)

# Build XML
rss = ET.Element('rss', version="2.0", attrib={"xmlns:itunes": "http://www.itunes.com/dtds/podcast-1.0.dtd"})
channel = ET.SubElement(rss, 'channel')
ET.SubElement(channel, 'title').text = "This American Archive"
ET.SubElement(channel, 'link').text = "https://www.thisamericanlife.org"
ET.SubElement(channel, 'description').text = "Autogenerated feed of the This American Life archive."
ET.SubElement(channel, 'language').text = "en"
ET.SubElement(channel, 'copyright').text = "Copyright Â© Ira Glass / This American Life"
ET.SubElement(channel, 'itunes:image', href="https://i.imgur.com/pTMCfn9.png")

for row in rows:
    items_to_write = []

    repeat_suffix = " - Repeat" if is_repeat(row['pubDate'], row['releaseDate']) else ""
    
    # base item
    items_to_write.append({
        "title": f"{row['itunes_title']}{repeat_suffix}",
        "enclosure": row['clean'] if row['clean'] else row['enclosure'],
        "explicit": "yes" if row['clean'] else "no"
    })
    
    # also add clean episode if available
    if row['clean']:
        items_to_write.append({
            "title": f"{row['itunes_title']}{repeat_suffix} (Clean)",
            "enclosure": row['clean'],
            "explicit": "yes"
        })
    
    for item_info in items_to_write:
        item_element = ET.SubElement(channel, 'item')
        ET.SubElement(item_element, 'title').text = item_info['title']
        ET.SubElement(item_element, 'link').text = row['link']
        ET.SubElement(item_element, 'itunes:episode').text = row['episode']
        ET.SubElement(item_element, 'itunes:episodeType').text = "full"
        ET.SubElement(item_element, 'itunes:explicit').text = item_info['explicit']
        # description: subtitle + description + Originally Aired
        desc_text = f"{row['subtitle']}\n\n{row['description']}\n\nOriginally Aired: {row['releaseDate'][:10]}"
        ET.SubElement(item_element, 'description').text = desc_text
        pub_date = row['pubDate'].strip() or row['releaseDate'].strip()
        ET.SubElement(item_element, 'pubDate').text = pub_date
        ET.SubElement(item_element, 'enclosure', url=item_info['enclosure'], type="audio/mpeg")

# Write XML
tree = ET.ElementTree(rss)
tree.write(XML_FILE, encoding="utf-8", xml_declaration=True)
print(f"Saved {len(rows)} episodes to {XML_FILE}")
