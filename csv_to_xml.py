import csv
from datetime import datetime, timezone
import email.utils
import xml.etree.ElementTree as ET

CSV_FILE = "tal_episodes.csv"
XML_FILE = "feed.xml"

# --- Date parsing helpers ---
def parse_date(row):
    date_str = row['pubDate'].strip() or row['releaseDate'].strip()
    if not date_str:
        return datetime.min.replace(tzinfo=timezone.utc)
    try:
        # pubDate: "Sun, 21 Sep 2025 18:00:00 -0400"
        dt = email.utils.parsedate_to_datetime(date_str)
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt
    except Exception:
        # releaseDate: "2025-09-19"
        dt = datetime.strptime(date_str, "%Y-%m-%d")
        return dt.replace(tzinfo=timezone.utc)

def iso_week(dt):
    return dt.isocalendar()[0:2]  # (year, week)

# --- Load CSV ---
with open(CSV_FILE, newline="", encoding="utf-8") as f:
    reader = list(csv.DictReader(f))
rows = sorted(reader, key=parse_date, reverse=True)

# --- RSS XML ---
rss = ET.Element("rss", version="2.0", attrib={"xmlns:itunes":"http://www.itunes.com/dtds/podcast-1.0.dtd"})
channel = ET.SubElement(rss, "channel")

ET.SubElement(channel, "title").text = "This American Archive"
ET.SubElement(channel, "link").text = "https://www.thisamericanlife.org"
ET.SubElement(channel, "description").text = "Autogenerated feed of the This American Life archive."
ET.SubElement(channel, "language").text = "en"
ET.SubElement(channel, "copyright").text = "Copyright Â© Ira Glass / This American Life"
ET.SubElement(channel, "itunes:image", href="https://i.imgur.com/pTMCfn9.png")

# --- Build items ---
for row in rows:
    release_dt = datetime.strptime(row['releaseDate'], "%Y-%m-%d")
    pub_dt = parse_date(row)
    title_base = row['title']

    # Determine repeat
    if pub_dt and iso_week(pub_dt) != iso_week(release_dt):
        title = f"{title_base} - Repeat"
    else:
        title = title_base

    # Description includes releaseDate at the bottom
    desc = f"{row['description']}\n\nOriginally Aired: {row['releaseDate']}"

    # Which audio URL to use first
    audio_url = row['clean'] if row['clean'].strip() else row['enclosure']

    def add_item(t, url):
        item_element = ET.SubElement(channel, "item")
        ET.SubElement(item_element, "title").text = t
        ET.SubElement(item_element, "link").text = row['link']
        ET.SubElement(item_element, "itunes:episode").text = row['episode']
        ET.SubElement(item_element, "itunes:episodeType").text = "full"
        ET.SubElement(item_element, "itunes:explicit").text = "yes" if row['clean'].strip() else "no"
        ET.SubElement(item_element, "description").text = desc
        ET.SubElement(item_element, "pubDate").text = row['pubDate'].strip() or row['releaseDate']
        ET.SubElement(item_element, "enclosure", url=url, type="audio/mpeg")

    # Normal item
    add_item(title, audio_url)

    # If clean exists, add separate clean item
    if row['clean'].strip():
        add_item(f"{title} (Clean)", row['clean'])

# --- Write XML ---
tree = ET.ElementTree(rss)
tree.write(XML_FILE, encoding="utf-8", xml_declaration=True)
print(f"Wrote {len(rows)} episodes to {XML_FILE}")
