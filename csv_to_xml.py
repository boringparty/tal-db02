import csv
from datetime import datetime
import xml.etree.ElementTree as ET
from xml.dom import minidom

CSV_FILE = "tal_episodes.csv"
XML_FILE = "feed.xml"

def iso_week(date_str):
    try:
        dt = datetime.strptime(date_str, "%Y-%m-%d")
        return dt.isocalendar()[1]
    except:
        return None

def parse_date(row):
    # Return datetime object: pubDate preferred, fallback to releaseDate
    pub_str = row.get("pubDate") or ""
    release_str = row.get("releaseDate") or ""
    dt = None
    if pub_str:
        try:
            dt = datetime.strptime(pub_str, "%a, %d %b %Y %H:%M:%S %z")
        except:
            dt = None
    if dt is None and release_str:
        try:
            dt = datetime.strptime(release_str, "%Y-%m-%d")
        except:
            dt = None
    return dt

# Read CSV
with open(CSV_FILE, newline="", encoding="utf-8") as f:
    reader = list(csv.DictReader(f))
    # Sort newest first
    rows = sorted(reader, key=parse_date, reverse=True)

# XML header
rss = ET.Element("rss", version="2.0", attrib={
    "xmlns:itunes": "http://www.itunes.com/dtds/podcast-1.0.dtd"
})
channel = ET.SubElement(rss, "channel")
ET.SubElement(channel, "title").text = "This American Archive"
ET.SubElement(channel, "link").text = "https://www.thisamericanlife.org"
ET.SubElement(channel, "description").text = "Autogenerated feed of the This American Life archive."
ET.SubElement(channel, "language").text = "en"
ET.SubElement(channel, "copyright").text = "Copyright Â© Ira Glass / This American Life"
ET.SubElement(channel, "itunes:image", href="https://i.imgur.com/pTMCfn9.png")

for row in rows:
    title_base = row["title"]
    pub_date_str = row["pubDate"]
    release_date_str = row["releaseDate"]

    # Determine repeat
    repeat = False
    if pub_date_str and release_date_str:
        try:
            pub_dt = datetime.strptime(pub_date_str, "%a, %d %b %Y %H:%M:%S %z")
            release_dt = datetime.strptime(release_date_str, "%Y-%m-%d")
            if pub_dt.isocalendar()[1] != release_dt.isocalendar()[1]:
                repeat = True
        except:
            pass

    title_final = f"{title_base}{' - Repeat' if repeat else ''}"

    description_text = f"{row['subtitle']}\n\n{row['description']}\n\nOriginally Aired: {release_date_str}"
    enclosure_url = row["clean"] if row["clean"] else row["enclosure"]

    # Regular item
    item = ET.SubElement(channel, "item")
    ET.SubElement(item, "title").text = title_final
    ET.SubElement(item, "link").text = row["link"]
    ET.SubElement(item, "itunes:episode").text = row["episode"]
    ET.SubElement(item, "itunes:episodeType").text = row["episodeType"]
    ET.SubElement(item, "itunes:explicit").text = "yes" if row["clean"] else "no"
    ET.SubElement(item, "description").text = description_text
    ET.SubElement(item, "pubDate").text = pub_date_str
    ET.SubElement(item, "enclosure", url=enclosure_url, type="audio/mpeg")

    # Clean item if available
    if row["clean"]:
        clean_item = ET.SubElement(channel, "item")
        ET.SubElement(clean_item, "title").text = f"{title_final} (Clean)"
        ET.SubElement(clean_item, "link").text = row["link"]
        ET.SubElement(clean_item, "itunes:episode").text = row["episode"]
        ET.SubElement(clean_item, "itunes:episodeType").text = row["episodeType"]
        ET.SubElement(clean_item, "itunes:explicit").text = "yes"
        ET.SubElement(clean_item, "description").text = description_text
        ET.SubElement(clean_item, "pubDate").text = pub_date_str
        ET.SubElement(clean_item, "enclosure", url=row["clean"], type="audio/mpeg")

# Pretty print and save
xml_str = minidom.parseString(ET.tostring(rss)).toprettyxml(indent="  ")
with open(XML_FILE, "w", encoding="utf-8") as f:
    f.write(xml_str)

print(f"Generated feed: {XML_FILE}")
