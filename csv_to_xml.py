import csv
from datetime import datetime
import xml.etree.ElementTree as ET
import re

CSV_FILE = "tal_episodes.csv"
XML_FILE = "feed.xml"

def parse_date(row):
    date_str = row.get("pubDate") or row.get("releaseDate")
    if not date_str:
        return datetime.min
    # Try RFC 2822 (pubDate)
    try:
        dt = datetime.strptime(date_str, "%a, %d %b %Y %H:%M:%S %z")
        return dt.replace(tzinfo=None)
    except ValueError:
        pass
    # Try ISO 8601 (releaseDate)
    try:
        dt = datetime.strptime(date_str[:10], "%Y-%m-%d")  # just the date part
        return dt
    except ValueError:
        return datetime.min

def get_isoweek(dt):
    return dt.isocalendar()[1]

def escape_xml(text):
    return (text.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace('"', "&quot;")
                .replace("'", "&apos;"))

# Read CSV
with open(CSV_FILE, newline="", encoding="utf-8") as f:
    reader = list(csv.DictReader(f))

# Sort by pubDate (fallback releaseDate)
rows = sorted(reader, key=parse_date, reverse=True)

# Build XML
rss = ET.Element("rss", version="2.0", attrib={"xmlns:itunes": "http://www.itunes.com/dtds/podcast-1.0.dtd"})
channel = ET.SubElement(rss, "channel")
ET.SubElement(channel, "title").text = "This American Archive"
ET.SubElement(channel, "link").text = "https://www.thisamericanlife.org"
ET.SubElement(channel, "description").text = "Autogenerated feed of the This American Life archive."
ET.SubElement(channel, "language").text = "en"
ET.SubElement(channel, "copyright").text = "Copyright Â© Ira Glass / This American Life"
ET.SubElement(channel, "itunes:image", href="https://i.imgur.com/pTMCfn9.png")

for row in rows:
    base_dt = parse_date(row)
    repeat_suffix = ""
    if row.get("pubDate") and get_isoweek(base_dt) != get_isoweek(parse_date({"releaseDate": row.get("releaseDate")})):
        repeat_suffix = " - Repeat"

    # base item
    item = ET.SubElement(channel, "item")
    ET.SubElement(item, "title").text = escape_xml(f"{row.get('itunes_title', '')}{repeat_suffix}")
    ET.SubElement(item, "link").text = escape_xml(row.get("link", ""))
    ET.SubElement(item, "itunes:episode").text = row.get("episode", "")
    ET.SubElement(item, "itunes:episodeType").text = row.get("episodeType", "full")
    ET.SubElement(item, "itunes:explicit").text = "no" if not row.get("clean") else "yes"
    description_text = f"{row.get('description','')}\n\nOriginally Aired: {row.get('releaseDate','')[:10]}"
    ET.SubElement(item, "description").text = escape_xml(description_text)
    if row.get("pubDate"):
        ET.SubElement(item, "pubDate").text = row.get("pubDate", "")
    url = row.get("clean") or row.get("enclosure")
    if url:
        ET.SubElement(item, "enclosure", url=url, type="audio/mpeg")

    # clean episode item
    if row.get("clean"):
        item_clean = ET.SubElement(channel, "item")
        ET.SubElement(item_clean, "title").text = escape_xml(f"{row.get('itunes_title', '')}{repeat_suffix} (Clean)")
        ET.SubElement(item_clean, "link").text = escape_xml(row.get("link", ""))
        ET.SubElement(item_clean, "itunes:episode").text = row.get("episode", "")
        ET.SubElement(item_clean, "itunes:episodeType").text = row.get("episodeType", "full")
        ET.SubElement(item_clean, "itunes:explicit").text = "yes"
        ET.SubElement(item_clean, "description").text = escape_xml(description_text)
        if row.get("pubDate"):
            ET.SubElement(item_clean, "pubDate").text = row.get("pubDate", "")
        ET.SubElement(item_clean, "enclosure", url=row.get("clean"), type="audio/mpeg")

# Write XML
tree = ET.ElementTree(rss)
tree.write(XML_FILE, encoding="utf-8", xml_declaration=True)
print(f"Generated {XML_FILE} with {len(rows)} episodes")
